<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>盒子模型</title>
    <style>
        /*css第一步初始化默认样式, 避免浏览器之间的差异，统一js获取的style结果*/
        
        * {
            margin: 0;
            padding: 0;
            font: 15px;
        }
        
        #d1 {
            width: 200px;
            height: 200px;
            margin: 100px;
            padding: 30px;
            border: 20px solid green;
            /* 强制文章不换行 */
            /* white-space: nowrap; */
            /*overflow: hidden;*/
            /* line-height: 30px; */
            opacity: 0.9;
            /* 透明度在IE6~8中不兼容 */
            filter: alpha(opacity=90);
            /* 不兼容的话通过使用滤镜来进行处理 */
            /*移动端渐变两套即可*/
            background: -webkit-linear-gradient(#11c900);
            background: linear-gradient(#11c900);
            background: -moz-linear-gradient(#11c900);
            background: -o-linear-gradient(#11c900);
        }
        /* 清除浮动 */
        
        .clear {
            zoom: 1;
        }
        
        .clear:after {
            display: block;
            content: '';
            width: 0;
            height: 0;
            overflow: hidden;
            clear: both;
        }
        /* css3新增加伪类：nth-child(even) odd */
        
        .list li:nth-child(1) {
            background-color: red;
        }
        
        #wapper {}
        
        #conBegin {}
    </style>
</head>

<body>
    <div id="d1" name="n1" class="c1">
        <!--因为div中，英文字母之间没有空格的话，它会默认认为这是一个英文单词，所以单词就一次输出不换行。-->
        <p>qweq weqwev qw eqweasdoei dfhjk vjnxz casdl klkmasd sdf</p>
    </div>


    <!--a标签href不写为刷新, #id为跳转至锚点，"javascript:void 0;"取消默认的跳转锚点和刷新-->
    <a href=""></a>

    <script>
        // 48 js盒子模型
        // #box -> HTMLDivElement.prototype -> HTMLElement.prototype ->
        // Element.prototype -> Node.prototype -> EventTarget.prototype ->
        // Object.prototype
        var box = document.getElementById("d1");
        // #box, ES5,所以IE8以上支持
        box.attributes.getNamedItem("id");
        var typ = document.createAttribute("class");
        typ.nodeValue = "democlass";
        box.attributes.setNamedItem(typ); // 参数：Node
        box.attributes.item(0);
        box.attributes.removeNamedItem("name");
        // class
        box.classList.add("123");
        box.classList.remove("123");
        box.className += "text100";
        // contentEditable，是否可在html上直接编辑 inherit,true
        // isContentEditable

        // 1、元素盒子模型
        // 1.client
        // clientHeight/clientWidth = 内容高度+上下/左右padding（和内容溢出没有关系）
        // clientLeft/clientTop = 左/上border的宽度
        // 2.offset
        // offsetHeight/offsetWidth = clientHeight/clientWidth + 上下/左右border（和内容溢出没有关系）
        // offsetParent: 当前元素的父级节点
        // offsetLeft/offsetTop 当前元素的【外】边框距离父级参照物的【内】边框偏移量
        // 3.scroll
        // scrollWidth/scrollHeight:  无溢出：clientWidth/clientHeight, 溢出：真实内容宽度/高度 + 左/上padding
        // 是否设置overflow='hidden'对最终结果有影响，在不同的浏览器中获取的结果也不相同
        // scrollLeft/scrollTop： 滚动条卷去的宽度/高度
        // 2、窗口盒子模型
        // document.documentElement.clientWidth/clientHeight 当前浏览器可视窗口高度
        // document.documentElement.scrollWidth/scrollHeight 当前页面的真实宽度和高度（scroll总高度）
        // document.documentElement.scrollTop/scrollLeft 当前页面已滚动高度/宽度
        // document.body.scrollTop/srcollLeft // 当前页面已滚动高度/宽度
        // document.documentElement[attr] || document.body[attr] //兼容写法, 必须document.documentElement在前
        // 设置时也需要写两套方案
        // document.documentElement.scrollTop = 0;
        // document.body.scrollTop = 0;
        // win：编写关于浏览器盒子模型的操作方法
        function win(attr, value) {
            // 读取
            if (typeof value === "undefined") {
                return document.documentElement[attr] || docment.body[attr];
            }
            // 设置
            document.documentElement[attr] = value;
            document.body[attr] = value;
        }
        // innerHtml, outerHTML, innerText, outerText
        // js盒子模型属性取值都是四舍五入取整

        // 获取具体样式信息getcss
        // 1.元素.style.属性名
        box.style.height //获取当前行内元素样式，style或.css内设置获取不到
            // 2.使用window.getComputedSytle方法获取所有经过浏览器计算（渲染）过的样式
        window.getComputedStyle(box, null)["height"];
        // 在IE6~8下不兼容，window下没有getComputedStyle这个属性，使用currentStyle属性
        box.currentStyle.height
            // 3.getCss兼容方法
            // 1、try,catch检测错误方法
            // curEle:[object]当前要操作的元素对象
            // attr: [string]我们要获取的样式属性的名称
            // 前提：1.try在代码不兼容时报错；2.try{}必须执行，消耗性能
        function getCss(curEle, attr) {
            var val = null;
            try {
                val = window.getComputedStyle(curEle, null)[attr];
            } catch (e) {
                val = curEle.currentStyle[attr];
            }
            return val;
        }
        // 2、检测window是否存在该方法
        function getCss(curEle, attr) {
            var val = null;
            // undefined转换为Boolean值false
            if (window.getComputedStyle) {
                val = window.getComputedStyle(curEle, null)[attr];
            } else {
                val = curEle.currentStyle[attr];
            }
            return val;
        }
        // 3、检测浏览器版本和类型来处理
        // window.navigator.userAgent
        // IE6-8
        function getCss(curEle, attr) {
            var val = null,
                reg = null;
            // var val = reg = null; reg的声明为全局（无var）
            if (/MSIE [6-8]/.test(navigator.userAgent)) {
                val = curEle.currentStyle[attr];
            } else {
                if (attr === "opacity") {
                    val = curEle.currentStyle["filter"];
                    reg = /^alpha\(opacity=(\d+(?:\.\d+)?)\)&/i;
                    val = reg.test(val) ? reg.exec(val)[1] / 100 : 1;
                } else {
                    val = window.getComputedStyle(curEle, null)[attr];
                }
            }
            reg = /^(-?\d+(\.\d+)?)(px|pt|rem|em)?$/i;
            return reg.test(val) ? parseFloat(val) : val;
        }
        // 但是ele.currentStyle和window.getComputedStyle获取的值仍然不一样
        // 如getCss(body, "margin")部分复合属性currentStyle没有
        // 所以通常将复合属性拆分, getCss(body, "marginTop")

        // 50伪类的应用补充
        // 无法获取伪类标签，但可获取伪类属性
        window.getComputedStyle(box, "before").content;
        // 51元素偏移量offset
        // offsetParent 指与位置有关的上级元素 (父级参照物)
        // parentElement 和 parentNode一样,但parentNode是W3C标准的parentElement 只在IE中可用.
        // offset: 等同于jQuery的offset方法，实现获取页面任意一个元素距离body的偏移量
        function offset(curEle) {
            var totalLeft = null,
                totalTop = null,
                par = curEle.offsetParent;
            totalLeft += curEle.offsetLeft;
            totalTop += curEle.offsetTop;
            while (par) {
                // 在标准的IE8浏览器中，使用offsetLeft/offsetTop已把父级参照物的边框宽度算在内
                if (navigator.userAgent.indexOf("MSIE 8.0") === -1) {
                    totalLeft += par.offsetLeft; // 边框宽
                    totalLeft += par.clientLeft; // 内容左距离
                }
                totalTop += par.offsetTop;
                totalTop += par.clientTop;
                par = par.offsetParent;
            }
            return {
                left: totalLeft,
                top: totalTop
            };
        }
        // 52scroll
        // client/offset/scrollWidth/scrollHeight 都是只读属性
        // scrollTop、scrollLeft，滚动条卷去的高度/宽度，为读写属性
        // document.documentElement.scrollHeight === docuemnt.body.scrollHeight
        // 最大值为div.scrollHeight - div.clientHeight(滚动条总高度-单屏幕高度)，最小值为0
        // 53回到顶部动画
        var timer1 = window.setTimeout(function() {}); // 1 -> 返回数字，代表当前是第几个定时器
        // setTimeout实现多次运动动画
        var i = 1;

        function move() {
            i++;
            console.log(i);
            window.setTimeout(move, 1000);
        }
        move();
        // ->回到顶部
        // 总时间（duration）:500ms;
        // 频率（interval）:多长时间走一步 10ms;
        // 总距离(target)：当前位置（scrollTop值）- 目标位置（0）
        // 步长(step): 每次移动的距离
        window.scroll = computedDisplay;
        goLink.onclick = function() {
            // 点击后消失
            this.style.display = "none";
            // 使绑定事件不触发
            window.scroll = null;
            var duration = 500,
                interval = 10,
                target = document.documentElement.scrollTop || document.body.scrollTop;
            step = (target / duration) * interval;
            var timer = window.setInterval(function() {
                var curTop = document.documentElement.scrollTop || document.body.scrollTop;
                if (curTop === 0) {
                    window.clearInterval(timer);
                    // 动画结束后重新绑定
                    window.onscroll = computedDisplay;
                    return;
                }
                curTop -= step;
                document.documentElement.scrollTop = curTop;
                document.body.scrollTop = curTop;
            }, interval);
        }

        function computedDisplay() {
            var curTop = document.documentElement.scrollTop || document.body.scrollTop;
            var curHeight = document.documentElement.clientHeight || document.body.clientHeight;
            goLink.style.display = curTop > curHeight ? "block" : "none";
        }

        // 54跑马灯效果
        // overflow:hidden盒子
        var box = document.getElementById("box");
        // 文字框
        var conBegin = document.getElementById("conBegin");
        var conEnd = document.getElementById("conEnd");

        function move() {
            conBegin.scrollLeft++;
            if (conBegin.scrollLeft >= conBegin.width) {
                // window.clearInterval(curLeft);
                conBegin.scrollLeft = 0; // 重头开始，有切换闪动的效果
            }
        }
        var timer = window.setInterval(move, 10);
        box.onmouseover = function() {
            window.clearInterval(timer)
        }
        box.onmouseout = function() {
            timer = window.setInterval(move, 10);
        }

        // 55js异步同步编程
        window.setTimeout(function() {}, 0);
    </script>
</body>

</html>