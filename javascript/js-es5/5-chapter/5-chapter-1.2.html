<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        #box {
            /*居中样式*/
           /* position: absolute;
            top: 50%;
            left: 50%;
            transform: translateY(-50%) translateX(-50%);
            或 margin: 宽高
            */
            /*ie 6\7不兼容， 主要运用于移动端*/
            /*position: absolute;
            top: 0;
            left:0;
            bottom:0;
            right: 0;
            margin: 0;*/
        }
    </style>
</head>

<body>
    <ul class="one">
        <li>
            <em>图标</em><span>第一级第一个</span>
            <ul class="two">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="three">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li><span>第三级第三个</span></li>
                        <li><span>第三级第四个</span></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <div id="box"></div>
    <script type="text/javascript">
        // 113多级菜单
        box.onclick = function(e) {
                e = e || window.event;
                var tar = e.target || e.srcElement;
                if (/^(em|span)$/i.test(tag.tagName)) {
                    var parent = tar.parentNode;
                    var oEm = utils.children(parent, "em")[0];
                    var firstUl = utils.children(parent, "ul")[0]; // 获取父亲子集中第一个标签
                    if (furstUl) {
                        var isBlock = utils.getCss(firstUl, "display") === "block" ? true : false;
                        if (isBlock) { //当前显示，使其隐藏
                            firstUl.style.display = "none";
                            oEm ? utils.removeClass(oEm, "open") : null;
                            // ->当外层收起，里层所有的Ul都要隐藏,且em移除open样式
                            var allUl = parent.getELementsByTagName("ul"),
                                allEm = parent.getELementsByTagName("em");
                            for (var i = 0; i < allUl.length; i++) {
                                allUl[i].style.display = "none";
                                utils.removeClass(allEm[i], "open");
                            }
                        } else { //当前隐藏，让其显示
                            furstUl.style.display = "block";
                            if (oEm) {
                                utils.addClass(oEm, "open")
                            }
                        }
                    }
                }
            }
            // 114jq多级菜单
        var $box = $("#box");
        $box.find("span").each(function() {
                var $pre = $(this).prev();
                if ($pre[0] && $pre[0].tagName.toLowerCase() === "em") {
                    $(this).css("cursor", "pointer");
                }
            })
            // bind, unbind, on, off: click, mouseover
            // delegate委托绑定方法
        function fn() {
            var $par = $(this).parent()
            var $ul = $($par.children("ul")[0]);
            var $em = $($par.children("em")[0]);
            if ($ul.length > 0) {
                var isBlock = $ul.css("display") === "block" ? true : false;
                // 将子孙节点所有ul/em都隐藏和移除open样式
                if (isBlock) {
                    $ul.slideUp();
                    $em.removeClass("open");
                    $par.find("ul").css("display", "none");
                    $par.find("em").removeClass("open");
                } else {
                    $ul.slideDown();
                    $em.addClass("open");
                }
            }
        }
        // $box绑定的事件源是em时，执行fn
        $box.delegate("em", "click", fn);
        $box.delegate("span", "click", fn);

        // 115拖拽
        // 思路一：鼠标按下时，给盒子绑定onmousemove和onmouseup事件；移动时计算盒子最新位置；鼠标mouseup时移除方法
        // js实现居中
        var box = document.getElementById("box");
        box.style.top = (docuemnt.documentElement.clientHeight || document.body.clientHeight) - box.offsetHeight / 2 + "px";
        box.style.left = (docuemnt.documentElement.clientWidth || document.body.clientWidth) - box.offsetWidth / 2 + "px";
        box.onmousedown = down;

        function down(e) {
            // 记录起始位置
            this["strX"] = e.clientX;
            this["strY"] = e.clientY;
            this["strL"] = parseFLoat(this.style.left);
            this["strT"] = parseFloat(this.style.top);

            // 解决焦点丢失问题
            if (this.setCapture) {
                // 鼠标绑定元素
                this.setCapture();
                // 给元素绑定事件
                this.onmousemove = move;
                this.onmouseup = up;
            } else {
                // _this -> box
                var _this = this;
                document.onomousemove = function(e) {
                    // 留意this的改变
                    move.call(_this, e);
                }
                document.onmouseup = function(e) {
                    up.call(_this, e);
                };
            }
        }

        function move(e) {
            e = e || window.event;
            var curL = (e.clientX - this["strX"]) + this["strL"];
            var curT = (e.clientY - this["strY"]) + this["strT"];
            // 边界判断
            var minL = 0,
                minT = 0,
                maxL = (document.documentElement.clientWidth || docuemnt.body.clientWidth) - this.offsetWidth,
                maxT = (document.documentElement.clientHeight || docuemnt.body.clientHeight) - this.offsetHeight;
            curL = curL < minL ? minL : (curL > maxL ? maxL : curL);
            curT = curT < minT ? minT : (curT > maxT ? maxT : curT);

            this.style.left = curL + "px";
            this.style.right = curT + "px";
        }

        function up(e) {
            this.onmousemove = null;
            this.onmouseup = null;
        }
        // 116鼠标丢失
        // 鼠标移动过快时，鼠标脱离盒子导致焦点消失
        // Ie和火狐浏览器中，可将盒子和鼠标绑定在一起
        this.setCapture(); // 绑定
        this.releaseCapture(); // 解绑
        // 在谷歌下不兼容Uncaught TypeError: this.setCapture is not a function
        // 把mousemove/mouseup绑定在document
    </script>
</body>

</html>