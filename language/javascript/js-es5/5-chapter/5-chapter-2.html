<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹性盒子</title>
    <style>
        #box {
            width: 100px;
            height: 100px;
            position: absolute;
            left: 100px;
            top: 100px;
            background-color: #666;
            /*transform: translateX(50%) translateY(50%);*/
        }
        /*禁止换行*/
        
        span {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            /*禁止选中*/
            -webkit-user-select: none;
        }
    </style>
</head>
<div id="box"></div>

<body>
    <script type="text/javascript">
        var box = document.getElementById("box");
        // DOM0级事件绑定：只能给元素的某个行为绑定一次方法，再绑定时方法被覆盖；
        // DOM2级事件可以给元素同一行为绑定多个不同的方法
        // box.addEventListener("click", function(e) {
        //     console.log(1);
        // })
        // box.addEventListener("click", function(e) {
        //         console.log(2);
        //     })
        // dom2: DOMContentLoaded(页面中的HTML结构加载完成触发)
        // box.addEventListener("DOMContentLoaded", function() {}, false);
        // window.onload = function(){} 页面中的所有资源都加载完（图片、HTML、结构）后执行。DOM0事件，只执行一次
        // jquery
        // $(document).ready(function() {}) // 可多次执行
        // $(function() {})
        // 原生DOM2实现
        // window.addEventListener("load", function() {})

        // 3.DOM2
        // function fn(e) {}
        // box.addEventListener("click", fn, false); // 用匿名函数因内存地址不知道无法移除（原理是绑定内存地址？）
        // box.removeEventListener("click", fn, false);
        // 4.DOM2事件池
        // 同一地址的函数，只能绑定一次
        // 当行为触发时，按绑定的先后顺序依次绑定
        // 执行方法中的this为监听对象

        // ie6~8不支持addEventListerner/removeEventListener:解决方法:attachEvent/detachEvent
        // box.attachEvent("onclick", fn); //只能在冒泡阶段发生，行为需要添加on..., 和DOM0类型
        // 区别(ie6~8)
        // 1、执行顺序：执行顺序混乱
        // 2、重复问题：可以给同一元素绑定多个相同（地址）的方法
        // 3、this问题: this为window

        // 118 DOM2兼容性
        function bind(curEle, eventType, eventFn) {
            if ("addEventListener" in document) {
                curEle.addEventListener(eventType, eventFn, false);
                return;
            }
            // 解决this问题
            // curEle.attachEvent("on"+eventType, eventFn);
            var tempFn = function() {
                eventFn.call(curEle);
            }
            tempFn.ori = evenFn;
            // 存储绑定函数
            // 加eventType处理不同类型事件绑定相同函数
            if (!curEle["myBind" + eventType]) {
                curEle["myBind" + eventType] = [];
            }
            // 判断重复
            var ary = curELe["myBind" + eventTpye];
            for (var i = 0; i < ary.length; i++) {
                var cur = ary[i];
                if (cur.ori === eventFn) {
                    return;
                }
            }
            ary.push(tempFn);
            curEle.attachEvent("on" + eventType, tempFn);
        }

        function unbind(curEle, eventType, eventFn) {
            if ("removeEventListener" in document) {
                cur.removeEventListener(eventType, eventFn, false);
                return;
            }
            var ary = curEle["myBind" + eventType];
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].ori === eventFn) {
                    curEle.detachEvent("on" + eventType, ary[i]);
                    ary.splice(i, 1); // ary内存地址相同
                    break;
                }
            }
        }
        // 120 自建事件池解决绑定顺序问题
        function on(curEle, eventType, eventFn) {
            if ("addEventListener" in document) {
                curEle.addEventListener(eventType, eventFn, false);
                return;
            }
            if (!curEle["myEvent" + eventType]) {
                curEle["myEvent" + eventType] = [];
            }
            var ary = curEle["myEvent" + eventType];
            for (var i = 0; i < ary.length; i++) {
                var cur = ary[i];
                if (cur === eventFn) {
                    return;
                }
            }
            ary.push(eventFn);
            // curEle.addEventListener(eventType, run, false); //绑定自定义run事件
            bind(curEle, eventType, run);
        }

        function off(curEle, eventType, eventFn) {
            if ("addEventListener" in document) {
                curEle.removeEventListener(eventType, eventFn, false);
                return;
            }
            var ary = curEle["myEvent" + eventType];
            for (var i = 0; i < ary.length; i++) {
                var cur = ary[i];
                if (cur === eventType) {
                    ary.splice(i, 1);
                    curEle.detachEvent("on" + eventTyle, cur);
                    break;
                }
            }
        }
        // 给目标元素绑定方法run，使其触发时按顺序执行
        function run(e) {
            // this -> e.target
            e = e || window.event;
            var flag = e.target ? true : false; // ie6~8不兼容e.target
            if (!flag) {
                e.target = e.srcElement;
                e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
                e.pageY = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
                e.preventDefault = function() {
                    e.returnValue = false;
                }
                e.stopPropagation = function() {
                    e.cancelBubble = true;
                }
            }
            // e.type
            var ary = e.target["myEvent" + e.type];
            for (var i = 0; i < ary.length; i++) {
                var tempFn = ary[i];
                tempFn.call(this, e);
            }
        }
        box.style.top = ((document.documentElement.clientHeight || document.body.clientHeight) - box.offsetHeight) / 2 + "px";
        box.style.left = ((document.documentElement.clientWidth || document.body.clientWidth) - box.offsetWidth) / 2 + "px";
        on(box, "mousedown", down);

        function down(e) {
            this["strX"] = e.pageX;
            this["strY"] = e.pageY;
            this["strL"] = parseFloat(this.style.left);
            this["strT"] = parseFloat(this.style.top);
            if (this.setCapture) { //ie\火狐
                this.setCapture();
                on(box, "mousemove", move);
                on(box, "mouseup", up);
            } else {
                var _this = this;
                this.MOVE = function(e) {
                    move.call(_this, e);
                }
                this.UP = function(e) {
                    up.call(_this, e);
                }
                on(document, "mousemove", this.MOVE);
                on(document, "mouseup", this.UP);
            }

            // 盒子运动中执行下一次拖拽，使盒子停止
            window.clearInterval(this.flyTimer);
            window.clearInterval(this.dropTimer);
        }

        function move(e) {
            var curL = e.pageX - this["strX"] + this["strL"];
            var curT = e.pageY - this["strY"] + this["strT"];
            var minL = 0,
                minT = 0,
                maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth,
                maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
            curL = curL < minL ? minL : (curL > maxL ? maxL : curL);
            curT = curT < minT ? minT : (curT > maxT ? maxT : curT);
            this.style.top = curT + "px";
            this.style.left = curL + "px";

            // 浏览器最小的反应时间是5ms
            // 计算水平位置
            if (!this.pre) {
                this.pre = this.offsetLeft;
            } else {
                this.speedFly = this.offsetLeft - this.pre;
                this.pre = this.offsetLeft;
            }
        }

        function up(e) {
            if (this.releaseCapture) {
                this.releaseCapture()
                off(this, "mousemove", move);
                off(this, "mouseup", up);
            } else {
                off(document, "mousemove", this.MOVE);
                off(document, "mouseup", this.UP);
            }
            // 水平移动
            fly.call(this);
            drop.call(this);
        }

        // 水平指数衰减运动
        function fly() {
            var _this = this;
            _this.flyTimer = window.setInterval(function() {
                // this:window
                // 在js盒子模型中，offsetLeft是获取当前元素的左偏移，为.style.left按小数四舍五入取得的值
                if (Math.abs(_this.speedFly) < 0.5) {
                    window.clearInterval(_this.flyTimer);
                    return;
                }
                _this.speedFly *= 0.98;
                var curL = _this.offsetLeft + _this.speedFly;
                var minL = 0,
                    maxL = (document.documentElement.clientWidth || document.body.clientWidth) - _this.clientWidth;
                if (curL >= maxL) {
                    _this.style.left = maxL + "px";
                    _this.speedFly *= -1;
                } else if (curL <= minL) {
                    _this.style.left = minL + "px";
                    _this.speedFly *= -1;
                } else {
                    _this.style.left = curL + "px";
                }
            }, 50)
        }

        // 垂直自由落体运动
        function drop() {
            var _this = this;
            _this.dropFlag = 0;
            _this.dropTimer = window.setInterval(function() {
                // 判断是否继续执行
                if (_this.dropFlag > 1) {
                    window.clearInterval(_this.dropTimer);
                    return;
                }
                _this.dropSpeed = !_this.dropSpeed ? 10 : _this.dropSpeed += 10;
                _this.dropSpeed *= 0.98;
                // console.log(_this.dropSpeed, _this.offsetTop);
                var curT = _this.offsetTop + _this.dropSpeed;
                var maxT = (document.documentElement.clientHeight || document.body.clientHeight) - _this.offsetHeight;
                if (curT >= maxT) {
                    _this.style.top = maxT + "px";
                    _this.dropSpeed *= -1;
                    _this.dropFlag++;
                } else {
                    _this.style.top = curT + "px";
                    _this.dropFlag = 0;
                }
            }, 50);
        }
    </script>
</body>

</html>