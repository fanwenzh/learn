<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Dom2事件绑定</title>
</head>

<body>
    <script type="text/javascript">
        var box = document.getElementById("box");
        // DOM0级事件绑定：只能给元素的某个行为绑定一次方法，再绑定时方法被覆盖；
        // DOM2级事件可以给元素同一行为绑定多个不同的方法
        box.addEventListener("click", function(e) {
            console.log(1);
        })
        box.addEventListener("click", function(e) {
                console.log(2);
            })
            // dom2: DOMContentLoaded(页面中的HTML结构加载完成触发)
        box.addEventListener("DOMContentLoaded", function() {}, false);
        // window.onload = function(){} 页面中的所有资源都加载完（图片、HTML、结构）后执行。DOM0事件，只执行一次
        // jquery
        $(document).ready(function() {}) // 可多次执行
        $(function() {})
            // 原生DOM2实现
        window.addEventListener("load", function() {})

        // 3.DOM2
        function fn(e) {}
        box.addEventListener("click", fn, false); // 用匿名函数因内存地址不知道无法移除（原理是绑定内存地址？）
        box.removeEventListener("click", fn, false);
        // 4.DOM2事件池
        // 同一地址的函数，只能绑定一次
        // 当行为触发时，按绑定的先后顺序依次绑定
        // 执行方法中的this为监听对象

        // ie6~8不支持addEventListerner/removeEventListener:解决方法:attachEvent/detachEvent
        box.attachEvent("onclick", fn); //只能在冒泡阶段发生，行为需要添加on..., 和DOM0类型
        // 区别(ie6~8)
        // 1、执行顺序：执行顺序混乱
        // 2、重复问题：可以给同一元素绑定多个相同（地址）的方法
        // 3、this问题: this为window

        // 118 DOM2兼容性
        function bind(curELe, eventType, eventFn) {
            if ("addEventListener" in document) {
                curEle.addEventListener(eventType, eventFn, false);
                return;
            }
            // 解决this问题
            // curEle.attachEvent("on"+eventType, eventFn);
            var tempFn = function() {
                eventFn.call(curEle);
            }
            tempFn.ori = evenFn;
            // 存储绑定函数
            // 加eventType处理不同类型事件绑定相同函数
            if (!curEle["myBind" + eventType]) {
                curEle["myBind" + eventType] = [];
            }
            // 判断重复
            var ary = curELe["myBind" + eventTpye];
            for (var i = 0; i < ary.length; i++) {
                var cur = ary[i];
                if (cur.ori === eventFn) {
                    return;
                }
            }
            ary.push(tempFn);
            curEle.attachEvent("on" + eventType, tempFn);
        }

        function unbind(curEle, eventType, eventFn) {
            if ("removeEventListener" in document) {
                cur.removeEventListener(eventType, eventFn, false);
                return;
            }
            var ary = curEle["myBind" + eventType];
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].ori === eventFn) {
                    curEle.detachEvent("on" + eventType, ary[i]);
                    ary.splice(i, 1); // ary内存地址相同
                    break;
                }
            }
        }
        // 120 自建事件池解决绑定顺序问题
        function on(curEle, eventTpye, eventFn) {
            if (!curEle["myEvent" + eventTpye]) {
                curEle["myEvent"] = [];
            }
            var ary = curEle["myEvent" + eventType];
            for (var i = 0; i < ary.length; i++) {
                var cur = ary[i];
                if (cur === eventFn) {
                    return;
                }
            }
            ary.push(eventFn);
            curEle.addEventListener(eventType, run, false); //绑定自定义run事件
        }

        // 给目标元素绑定方法run，使其触发时按顺序执行
        function run(e) {
            // this -> e.target
            e = e || window.event;
            var flag = e.target ? true : false; // ie6~8不兼容e.target
            if (!flag) {
                e.target = e.srcElement;
                e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
                e.pageY = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
                e.preventDefault = function() {
                    e.returnValue = false;
                }
                e.stopPropagation = function() {
                    e.cancelBubble = true;
                }
            }
            // e.type
            var ary = e.target["myEvent" + e.type];
            for (var i = 0; i < ary.length; i++) {
                var tempFn = ary[i];
                tempFn.call(this, e);
            }

        }
    </script>
</body>

</html>