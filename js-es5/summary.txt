### 1
	基本数据类型5: Undefined, Null, Number, String, Boolean
	引用数据类型: Array、Function、Math、Date、JSON、RegExp、Error
	判断:
	精确区分: Object.prototype.toString.call() === "[object Array]"
	模糊区分方法3: .constructor, instanceOf, typeof  
	isNaN, Array.isArray()

	预解释：
	var -> (声明提升)预解析是只提前声明 undefined
	function -> 预解析时声明并定义(声明提升)

	栈内存: 用来提供供js代码执行的环境（函数执行一次形成一个栈内存）
	堆内存: 用来存储引用数据类型的值 -> 对象存储的是属性名和属性值, 函数存储的是d代码字符串(声明并赋值形成堆内存)

	自执行函数:
	~function(num){}(100)

	1.函数中有this, 但是它没有以对象方法的形式调用，而是以函数名的形式执行，this指向的就是全局对象;
	2.函数中有this，并且这个函数是以对象方法的形式调用，那么this指向的就是调用该方法的对象
	3.函数中有this，并且包含该函数的对象也同时被另一个对象所包含，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象
	4.构造函数或类方法中有this，那么它指向由该构造函数或类创建出来的实例对象。
		DOM中回调函数的this指触发事件的对象

	hasOwnProperty, propertyIsEnumberable, isPrototypeOf, Object.getPrototypeOf
	Object.create()

DOM
	childNodes:NodeList 文档、元素、元素属性、文本、注释都为节点
	firstChild: 第一个子节点
	lastChild: 
	nextSibling: 下一个节点
	previousSibling
	parentNode

	.style.  所有style属性
	window.getComputedStyle(dom, [null":after"]).height
	
	//childElementCount: 子元素个数
	//children: HTMLCollection(类Array)，[i]访问，储存子元素
	//box.currentStyle.height
	firstElementChild: 第一个element子元素
	lastElementChild: 
	nextElementSibling: 下一个兄弟element元素
	previousElementSibling
	parentElement

    // DOM的增删改
    createElement
    document.createDocumentFragment()
    appendChild
    insertBefore          // 父节点调用，添加在某一子节点
    cloneNode(true/false) // 克隆节点内的所有元素/只克隆当前节点
    replaceChild
    removeChild
    get/set/removeAttribute

	*attributes:NamedNodeMap(类Array)  储存div所有属性
	className, id, tagName, hidden(style属性?), localName. nodeName, textContent,  nodetype
	clientHeight, clientWidth: padding+内容 
	clientLeft, clientTop : border宽度
	offsetHeight, offsetWidth: (padding+内容 = clientXXX) + border宽度
	offsetLeft, offsetTop, 相对于版面或父坐标offsetPartent的位置信息
	offsetPartent 返回父节点
	scrollHeight, scrollLeft: 滚动区域的总宽高
	scrollTop, scrollWidth: 已滚动(屏幕外)的高度

	DOM盒子模型
    clientHeight, clientWidth, clientTop, clientLeft
    offsetHeight, offsetWidth, offsetTop, offsetLeft, offsetParent
    scrollHeight, scrollWidth, scrollTop, scrollLeft

    css盒子模型
    margin, padding, box-sizing:border-box

### 2
	// 获取元素方法 
	document.getElementById // 上下文是document  //HTMLDocument -> Document
	document.getElementsByName // 上下文是document
	document.getElementsByClassName // 元素  // HTMLDivElement -> HTMLElement ->Element
	document.getElementsByTagName // 元素
	// css方法
	document.querySelector
	document.querySelectorAll

	document.documentElement
	document.body

	document.forms
	document.images
	// 屏幕宽高(html)
	document.documentElement.clientWidth
	document.documentElement.clientHeight
	document.documentElement.clientTop
	document.documentElement.clientLeft
	// 屏幕宽高, 多用于兼容IE
	document.body.clientHeight
	document.body.clientWidth
	document.body.clientLeft
	document.body.clientTop

	// #div.__proto__ -> HTMLDivElement.prototype -> HTMLElement.prototype -> Element.prototype ->
	// Node.prototype -> EventTarget.prototype -> Object.prototype
	// document.__proto__ -> HTMLDcoment -> Document -> Node.prototype

	Function.prototype.__proto__ === Object.prototype， 函数本身就是Objcet
	Function.__proto__ === Function.prototype // funcition anonymous(){}
	Object.__proto__ 没有__proto__;
	// 函数属性：
	// length: 形参的个数
	// name: 函数名
	// prototype 类原型，在原型上定义的方法都是当前Fn这个类实例的共有方法
	// ___proto__ 作为对象的函数，指向Function类的原型对象

	JSON.parse(), JSON.stringify()

	text-overflow: ellipsis; // ellipsis: 截取后以...作为省略，clip: 没有省略号
	overflow: hidden; // 隐藏溢出
	white-space: nowrap; // 强制不换行

	Array.prototype.forEach.call(oLis, function(){})

	js中Dom的重排(reflow)和重绘
	重排：页面中的HTML结构发生改变（增加、删除元素、位置变化），浏览器重新计算DOM结构，并进行渲染
	1.Dom元素的几何属性发生变化
	2.Dom树的结构变化
	3.获取某些元素
	offsetTop、offsetLeft、offsetWidth、offsetHeight
	scrollTop、scrollLeft、scrollWidth、scrollHeight
	clientTop、clientLeft、clientWidth、clientHeight
	getComputedStyle() 
	重绘：某一个元素的样式发生变化（如背景），浏览器只需要重新渲染当前的元素

	document.createDocumentFragment, document.createElement

    //表格排序操作
    //table // cellspacing, cellpadding = "0"
    // thead tbody tr th
    var table = document.getElementById("tab");
    // 表格特有属性：第一行rows[0], 所有列cells
    var oThs = table.tHead.rows[0].cells;
    // 获取tBody
    var tBody = table.tBodies[0];
    // 获取第一行所有列
    var oRows = tBody.rows;

    正则匹配
    var reg = new RegExp("^\\d+" + name + "\\d+$", "gim");
    reg.test(), .exec(): ["大正则捕获内容", index: "开始的索引位置", "原始字符串"] or null
    str.match(reg): 把所有正则匹配都捕获到
	// 元字符：每一个正则表达式式由元字符和修饰符组成，在//之间具有意义的字符
	// 1.特殊元字符
	// \ :转义字符, ^ 开头, [^] 非, $ 结尾, 
	* \n: 匹配一个换行符, . 匹配除\n以外的任意字符
	// (): 分组, RegExp.$1,
	// x|y: x或y， [xyz]: xyz任一字符， [^xyz]除了xyz的人一个字符，[a-z]
	* \d: [0-9], \D 除了0-9以外的所有字符
	// \b: 一个边界符, "w1 w2 w3" -> ""|w1| |w2| |w3|", \B匹配除了边界符以外的
	* \w: 数字、字母、下划线的任一个字符, [0-9a-zA-Z_], \W
	* \s: 匹配一个空白符、空格、制表符、换页符, \S
	// 2.两次元字符
	// * 0-n, + 1-n, ? 0-1, {n}, {n, }, {n, m}

	// 去除重复
	str = str.replace(/(\w)\1+/g, "$1");
	// 划分类名
	var ary = className.replace(/(^ +| +$)/, "").split(/ +/g);

	?的作用
	1)在普通元字符后代表出现0-1次，/\d?/ 
	2)放在一个量词后面的元字符后面取消捕获的贪婪性 +?
	3)(?:)在分组中?:的意思是只匹配，不捕获
	4)正则正向预测匹配(?=): str.replace(/(?=(\d{3})+$)/g, ',');

### 3
	opacity: 0.9;
    /* 透明度在IE6~8中不兼容 */
    filter: alpha(opacity=90);

    .clear:after {
        display: block;
        content: '';
        overflow: hidden;
        clear: both;
    }

    <a href="javascript:void 0;"></a>

    // #box -> HTMLDivElement.prototype -> HTMLElement.prototype ->
    // Element.prototype -> Node.prototype -> EventTarget.prototype ->
    // Object.prototype

	/*可省*/
    var box = document.getElementById("d1");
  * box.getAttribute("id");  
    box.attributes.getNamedItem("id");
    var typ = document.createAttribute("class");  // 创建新的attr节点
    typ.nodeValue = "democlass";                  // 设置节点value
    box.attributes.setNamedItem(typ); // 参数：Node
    box.attributes.item(0);
    box.attributes.removeNamedItem("name");

    // class, contains(), toggle
    box.classList.add("123");
    box.classList.remove("123");
    box.className += "text100";

    window.getComputedStyle(box, null(或伪类))["height"];
    box.currentStyle.height // ie6~8

	/*检查兼容*/
    /MSIE [6-8]/.test(navigator.userAgent)
	navigator.userAgent.indexOf("MSIE 8.0")

	// 已加载图片不再进行处理
    if (curImg.isLoad) {
        continue;
    }

    function lazyImgs(ele) {
        var oImg = new Image;
        oImg.src = ele.getAttribute("trueImg");
        oImg.onload = function() {
            ele.src = oImg.src;
            ele.style.display = "block";
            oImg = null;
        }
        ele.isLoad = true;
    }

    background: url() no-repeat center center // 添加默认图

    /*清除子元素浮动对父级的影响*/
    /*overflow: hidden;*/
	/*清除哥哥元素浮动对子元素的影响*/
    /*clear:both;*/

###4
    //jq
    .attr() // 使用更频繁（两者不通用）
    .prop() // 内置属性
    // jq可进行集合操作
    $boxDivList = $("div", $box); // (selector, context)
    $boxDivList.addClass("c1"); // 内置遍历
    $boxDivList.removeClass("c1");
    $boxDivList.each(function() {}); // 手动遍历

    // jq 回调函数
    var $call = $.Callbacks();
    $call.add(fun1);
    $call.fire(arguments);
    $call.remove(fun1);

    $.ajax({
        url: "www.baidu.com",
        type: "get",
        dataType: "json", //->text, html, jsonp（跨域通信）
        async: false, 
        success: function(data) {
            console.log(data);
        }
    })
 	事件
    $("#box").on("click", function(){
        this: 当前元素（js原生对象）
    })

    工具
    $("div").each(function(index, item){})
    $.each([1,2,3], function(index, item){})
    $.makArray()

    效果动画
    $.("#box").animate({left:xxx},[speed]during,[easing],[fn])
    .stop(), .finish(), .delay()

    window.jQuery = window.$ = jQuery
    jQuery.extend({ aa: function() {} }) -> $.aa();      //向jq类库中增加其他方法
    jQuery.fn.extend({ bb: function() {} }) -> $().bb(); // 先创建jq对象$(),后执行bb()函数;向jQuery原型上扩展，编写jquery插件
    
 ### 5
 	onclick, mouseover(mouseenter), mouseout(mouseleave), onmousemove, onmousedown, onmouseup, onmousewheel, onscroll
 	onresize, onload, onunload, onfocus, onblur
 	onkeydown, onkeyup, onkeypress -> oninput, onchange代替

	e: MouseEvent -> UIEvent -> Event -> Object
 	DOM0, 只能绑定一个事件
	box.onclick = function(e){}
	DOM2:
	box.addEventListener("click", function(){})
		*//ie6~8:只支持冒泡事件，且dom2事件this为window;
		attachEvent("onclick", function(){}), detachEvent("onclick", function(){}) 
	e = e || window.event
	e.target = e.target || e.srcElement
	e.clientX, e.clientY  //移动端 e.touches[0].clientX
	e.pageX = e.pageX = e.pageX || (e.clientX + (document.documentELement.scrollLeft || document.body.scrollLeft));
	// 阻止默认行为
	e.preventDefault() // e.returnValue = true
	e.stopPropagation() // e.cancelBubble = true

	事件委托
	e.target = e.target || e.srcElement  or e.target.tagName.toLowerCase(), e.target.parentNode.id

	居中样式:
	.div {
		position: absolute;
		top: 50%;
		left:50%;
		transform: translate(50%, 50%);
		/*或 margin: 固定宽高*/
	}
	.div {
		display: table-cell;
	}
	/*ie6~7不兼容，主要用于移动端*/
	.div {
		position: absolute;
		top:0;
		left:0;
		right: 0;
		bottom:0;
		margin: auto;
	}
	/*4 插空div*/

	/*禁止选中*/
	-webkit-user-select: none;

    dom2: DOMContentLoaded(页面中的HTML结构加载完成触发)
    box.addEventListener("DOMContentLoaded", function() {}, false);
    window.onload = function(){} 页面中的所有资源都加载完（图片、HTML、结构）后执行。DOM0事件，只执行一次
    jquery
    $(document).ready(function() {}) // HTML结构加载完成会触发，页面中可以触发多次
    $(function() {})
    window.addEventListener("load", function() {})
	DOM2事件：当行为触发时，按绑定的先后顺序依次绑定

	绑定鼠标
	this.setCapture();  //ie\火狐
	设置目标移动: move.call(target, 位移)

###7
	//协议      域名      端口号 ： 同源           
	http://www.baidu.com:80  220.123.23.23(外网ip地址) 80(服务器端口号)
	服务器端口号(0~64435)，80:http, 443:https, 21:FTP
	search: ?name=fanwenzh&age=18:url的传参
	query: name=fanwenzh&age=18

	xhr.open("get", "url", false, [username], [userpass]);
	xhr.setRequestHeader("hi", "tony");
	xhr.timeout = "1000"; // 设置AJAX请求超时时间
	xhr.ontimour = functoin(){}
	xhr.onreadystatechange = function() {
	        // xhr.readyState
	        // 0: UNSENT 当前的请求还没发送
	        // 1: OPENED  url地址已经打开（发送前参数设置完成）
	        // 2: HEADERS_RECEIVED 响应头信息已经接受 // xhr.readyState == 2 获取服务器响应头时间 xhr.getResponseHeader("Date")
	        // 3: LOADING 服务器长在处理返回的内容
	        // 4: DONE 响应主体已经成功返回客户端
	        // xhr.status:HTTP网络状态码
	        // 200 or ^2\d{2} 响应主体成功返回
	        // 301 永久重定向/永久转移, www.360buy.com
	        // 302 临时重定向/临时转移  服务器的负载均衡
	        // 304 本次获取的内容是读取缓存内存中的数据
	        // 400 客户端传递给服务器的参数出现未知错误
	        // 401 无权限访问
	        // 404 客户端访问的地址不存在
	        // 500 未知的服务器错误
	        // 503 服务器已经超负荷

	        if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)) {
	            var data = xhr.responseText;
	        }
	    }
	    // 参数是请求主体中传递给服务器的内容；
	xhr.send();
	// XMLHttpRequest -> XMLHttpRequestEventTarget -> EventTarget -> Object
	xhr.addEventListener("readystatechange", function() {}) // DOM2

	window.location.href = ""
	window.open()
	window.opener  // 父窗口.子窗口

	node:
   	var conFile = fs.readFileSync("." + pathname, "utf8");
    response.writeHead(200, {'content-type': suffixType + ";charset=utf-8;"});
    response.end(conFile);

    JSONP:
    function fn(data){}
    var url = "http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&cb=fn";
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.(or body)getElementsByTagName('head')[0].appendChild(script);
    jq实现
    $.ajax({
        url: url,
        // type: "get",
        dataType: "jsonp", //格式为jsonp!
        // data: null,
        // async: true,
        // cache: false, // url添加随机数，get请求不要缓存
        jsonpCallback: "fn", //自定义传递给服务器测函数名为fn,而不是jquery生成的随机函数名
        jsonp: "cb",         //把传递函数名的形参callback变为cb, 即&cb=fn
        success: function(data) {
            console.log(data);
        },
        error: function(e) {}
    })

###9
	HTML5新特性：
	<!--html5: search, url, email, tel, number, range, color, date, time, dataTime-->
    <input type="number" min="60" max="100" step="10" value="50">
	js的input.checkValidity()
	css3的input.valid / .invalid
	placeholder="提示信息"; ie6~9不支持，用span覆盖来实现提示

	移动端：
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<!--[if lt IE 9]>
        <script></script>
    <![endif]-->

    检测移动端的方法:
    mobileTest.js
    http://www.cnblogs.com/mrdoor/p/5560775.html
    动画用CSS3实现：swiper, animate, ISCroll, Wow

    适配：
    // DPI适配: 不同尺寸的图片素材
    // logo.png 100*100
    // logo@2x.png 200*200
    // logo@3x.png 300*300
    1.流式布局:
	-容器或盒子宽度width使用百分比
    -其余样式（字体, 高度, margin, padding按设计稿标注尺寸的一半）
    -部分屏幕尺寸使用@media进行微调:
    媒体查询: @media
    媒体设备: all, screen(所有屏幕设备，pc+移动端), print打印设备...
    媒体条件: 
    @media all and (min-width:320px) and (max-width:359px){}  >=320, <360
    media all and (device-pixel-ratio: 2m .0){}
    2.rem响应式布局
    动态计算font-size的值
    ~ function() {
        var desW = 640,
            winW = document.documentElement.clientWidth, // ie6~8不支持rem, 不用兼容
            ratio = winW / desW;
        var oMain = document.getElementById("main");
        // 超过设计稿大小设置最大值，剩余部分留白显示（如京东）
        if (winW > desW) {
            oMain.style.width = desW + 'px';
            oMain.style.margin = '0 auto';
            return;
        }
        document.documentElement.style.fontSize = ratio * 100 + 'px';
    }()
    // 阻止touch move原生事件,同touch.js
    $(document).on('touchmove touchstart touchend', function(e) {
        e.preventDefault();
    });

    1.pc端事件
    click, mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup
    mousewheel, keydown, keydown, DOMContentLoaded(DOM树加载完成), load(所有资源加载完成), unload, beforeunload, scroll, blur, focus, change
	// e.clientX, e.clientY, e.pageX, e.pageY
    3.移动端:
    click(单击), load, scroll, blur, focus, change和input, textInput(代替keyup, keydown键盘输入e.keycode)
    touch事件模型（单指操作）：touchstart, touchmove, touchend, touchcancel(操作过程中程序退出触发, 少用)
    gesture事件模型（多指操作）：gesturestar, gesturechange, gestureend //e多包含rotation和scale属性
    onorientationchange(屏幕旋转事件模型)
    event.preventDefault()
	//e.touches, targeTouchs, changeTouches(touchend)
	//e.touches[0].clientX, e.touches[0].clientY, pageX, pageY, screenX, screenY
	触摸事件顺序: touchstart -> mouseover -> mousemove -> mousedown -> mousedup -> click -> touchend
 
    单击和双击(300ms)
    点击和长按(750ms)
    点击和滑动(x/y轴偏移距离是否在30px以内)
    左右滑动和上下活动：X轴偏移距离 > Y轴偏移距离 为 左右滑动，反之为上下滑动

    3.移动端事件库(能ccs完成不用js，原生写完不用框架)
    fastclick.js： 解决click事件300MS的延迟
    touch.js： 百度云手势事件库:https://github.com/Clouda-team
    hammer.js： 移动端手势事件库：https://github.com/hammerjs/hammer.js
    zepto.js： 移动端事件：tap, singleTap, doubleTap, longTap, swipe, swipeUp, swipeDown, swipeLeft, swipeRight
    $('.box').singleTap(function(e){
        $(this).andmiate({目标值}, 1000, 'linear', function(){
            this.style.webkitTransform = 'rotate(0deg)';
        })
    }).on('touchstart', function(){});
    4.移动端支持
    position:fixed固定定位很多手机支持不好，尤其在定位的区域有虚拟键盘的弹出、收回
    原因：
    软键盘唤起后，页面的fixed元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。
    解决方案：
		1.fixed元素内部必须嵌套一个position:absolute元素，用来装载内容
    	2.局部滚动处理(iscroll) 或 swiper(较大)

    // HTML5:webStorage
    1.localStorage:永久存储到客户端的本地
    // localStorage.setItem([key],[value]); // 自动转换为字符串存储
    // localStorage.getItem([key]);
    // .removeItem([key])
    // .clear(), .length, .key(0)
    2.sessionStorage: 信息会话存储，会话窗口关闭信息消除
	3.cookie
	// cookie 与 localStorage的区别
    // cookie存储内容大小有限制, 同源4kb, 有过期时间，无痕浏览器禁用cookie，可被浏览器、杀毒软件查找并删除; cookie的size单位为byte, 兼容所有浏览器
    // localStorage: 同源5MB，不兼容ie6~8

    






















